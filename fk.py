import numpy as np
from conversions import *
from operations import *
from jacobians import *

VecN = np.ndarray       # (N,)
MatNx3 = np.ndarray     # (N, 3)

def get_screw_axis_rev(w: Vec3) -> Vec6:
    """
    Args:
        w: Angular Velocity Vector

    Returns:
        Screw Axis 
    """
    return np.array([0, 0, 0, w[0], w[1], w[2]])

def get_screw_axis_pris(v: Vec3) -> Vec6:
    """
    Args:
        v: Linear Velocity Vector

    Returns:
        Screw Axis
    """
    return np.array([v[0], v[1], v[2], 0, 0, 0])

def rebase(Ts, T, B = np.eye(4)):
    """
    Changes the base to another frame on the robot, additionaly can move this new base to required location in the world
    
    Args:
        Ts (MatNx4x4): All frames
        T (Mat4x4): The frame on the robot which you want to rebase to.
        B (Mat4x4): If you want to additionally move the new base to a specific configuration in world frame, then B is the world frame configuration.
                    Default : Identity matrix
    """
    new_Ts = []
    for t in Ts:
        new_Ts.append(B @ np.linalg.inv(T) @ t)
        
    return new_Ts

class FK1:
    """
    This class implements forward kinematics for serial manipulators with revolute and prismatic joints.
    
    Links and joints are treated uniformly as transformations generated by screw motions:
    
    - Links (type 0): Static transformations with fixed displacement
        - Represented as: exp(screw * link_length)
        - The 'vel' parameter defines the direction of translation
        - The 'link_lens' parameter defines the magnitude of translation
        
    - Revolute Joints (type 1): Rotations about an axis
        - Represented as: exp(screw * (reference_angle + joint_angle))
        - The 'vel' parameter defines the axis of rotation (angular velocity)
        - Joint angle is variable (from q vector)
        
    - Prismatic Joints (type 2): Translations along an axis
        - Represented as: exp(screw * (reference_offset + joint_displacement))
        - The 'vel' parameter defines the direction of translation (linear velocity)
        - Joint displacement is variable (from q vector)

    """
    
    def __init__(self, vels: MatNx3, joints: VecN, link_lens: VecN, reference_conf: VecN, B: Mat4x4 = np.eye(4)):
        """
        Parameters
        ----------
            vels : MatNx3, shape (N, 3)
                Velocity vectors defining screw axis directions:
                - For revolute joints: angular velocity vector (rotation axis)
                - For prismatic joints/links: linear velocity vector (translation direction)
                Each row corresponds to one element in the kinematic chain.
                
            joints : VecN, shape (N,)
                Joint/link type indicators:
                - 0: Link (fixed translation)
                - 1: Revolute joint (rotation)
                - 2: Prismatic joint (translation)
                
            link_lens : VecN, shape (N,)
                Fixed displacement magnitudes:
                - For links (type 0): translation distance along vel direction
                - For joints (type 1, 2): set to 0 (unused)
                
            reference_conf : VecN, shape (num_joints,)
                Reference configuration for actuated joints only (types 1 and 2):
                - For revolute joints: reference angle in radians
                - For prismatic joints: reference offset distance
                Length equals the number of joints (excluding links).
                
            B : Mat4x4, shape (4, 4), optional
                Base configuration as SE(3) transformation matrix.
                Default is identity (origin with no rotation).
            
        Notes
        -----
        - The kinematic chain is evaluated left-to-right (base to end-effector)
        - Transformations are composed using matrix multiplication: T = B @ T1 @ T2 @ ...
        - The unified screw representation means links are essentially "frozen joints"
        - Only actuated joints (types 1, 2) contribute to the q vector


        """
        self.B = B
        self.vels = vels
        self.joints = joints
        self.link_lens = link_lens
        self.reference_conf = reference_conf
        
        self.screws = []
        for i in range(len(joints)):
            if joints[i]==0 or joints[i]==2:
                self.screws.append(se3_repr(get_screw_axis_pris(vels[i])))
            elif joints[i]==1:
                self.screws.append(se3_repr(get_screw_axis_rev(vels[i])))    
        
    def fk(self, q: VecN) -> Mat4x4:
        """
        Compute forward kinematics for given joint configuration
        
        Args:
            q (VecN): joint configuration

        Returns:
            Mat4x4: End effector SE(3) configuration
            MatNx4x4: Configuration of every frame
        """
        T = self.B
        Ts = []
        Ts.append(self.B) # First Append Base
        k=0
        
        self.joint_Ts = []
        self.joint_screws = []
        
        for i in range(len(self.screws)):
            if self.joints[i]==0:
                T = T @ se3_exp(self.screws[i]*self.link_lens[i])
                Ts.append(T)
            else:
                T = T @ se3_exp(self.screws[i]*(self.reference_conf[k]+q[k]))
                k+=1
                Ts.append(T)
                self.joint_Ts.append(T)
                self.joint_screws.append(self.screws[i])

        return T, Ts
    
    def compute_jacobians(self, g):
        Js = get_spatial_jacobian(self.joint_Ts, self.joint_screws)
        Jb = get_body_jacobian(g, Js)
        Jw = get_world_jacobian(g, Js)
        
        return Js, Jb, Jw
    
        

if __name__=="__main__":
    # Example: 2R Robot
    joints = [1, 0, 1, 0]   # joint, link, joint, link
    vels = [[0, 0, 1],      # joint 1: rotate about z-axis
            [1, 0, 0],      # link 1: translate in x-direction
            [0, 0, 1],      # joint 2: rotate about z-axis
            [1, 0, 0]]      # link 2: translate in x-direction
    link_lens = [0, 2, 0, 1] # link 1 is 2 units, link 2 is 1 unit
    reference_conf = [0, np.pi/2] # reference configuration for the joints
    B = np.eye(4)
   
    robot_fk = FK1(vels, joints, link_lens, reference_conf, B)
    T, Ts = robot_fk.fk([0,-np.pi/2])
    print(T)
    print(xyz_rpy_from_SE3(T))
    
    new_Ts = rebase(Ts, Ts[-1], SE3_from_xyz_rpy(4,0,0,0,0,0))
    print(xyz_rpy_from_SE3(new_Ts[0]))
    
    Js, Jb, Jw = robot_fk.compute_jacobians(SE3_from_xyz_rpy(3,0,0,0,0,np.pi/2))
    print(Js @ [1,0])
    print(Jb @ [1,0])
    print(Jw @ [1,0])
    
